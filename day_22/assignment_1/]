{-# LANGUAGE FlexibleContexts #-}
module Main (main) where

import ClassyPrelude
import qualified Control.Monad as C
import qualified Control.Monad.State as C
import qualified Data.Char as Char
import qualified Data.Set as Set
import Qualified Data.Word as Word
import Prelude ()
import qualified System.Exit as S

type Position = (Integer, Integer)
type Infected = Set Position
data Direction = U | D | L | R

main :: IO ()
main = do
    input <- parseInput <$> getContents

    states <- C.evalStateT (C.replicateM 10000 $ burst input) ((0, 0), U)

    print . fmap Set.size . lastMay $ states

bursts :: (C.MonadState (Position, Direction) m) => Integer -> Cluster
bursts n | n > 0 =

burst :: (C.MonadState (Position, Direction) m) => Infected -> m Infected
burst infected = do
    (position, direction) <- C.get

    let isInfected = position `member` infected
        direction' = bool (right direction) (left direction) isInfected
        position' = move position direction'

    C.put (position', direction')

    if isInfected
        then return $ deleteSet position infected
        else return $ insertSet position infected
  where
    right U = R
    right D = L
    right L = U
    right R = D

    left U = L
    left D = R
    left L = D
    left R = U

    move (x, y) U = (x    , y + 1)
    move (x, y) D = (x    , y - 1)
    move (x, y) L = (x - 1, y    )
    move (x, y) R = (x + 1, y    )

parseInput :: LText -> Infected
parseInput txt = setFromList . map snd . filter (isHash . fst). zip nodes $ idx
  where
    nodes = filter (not . Char.isSpace) . toList $ txt
    size = (flip div) 2 . fromIntegral . length . lines $ txt
    idx = [(y, x) | x <- [size,size-1..(-size)], y <- [-size..size]]
    isHash x = x == '#'
